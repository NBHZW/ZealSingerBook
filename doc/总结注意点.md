# 各接口中数据的缓存数据类型形式

## 笔记点赞缓存

```
zset结构
key结构  user:note:likes: 用户 ID
value  集合形式 对应笔记 id（noteId）
score   权重为点赞时间戳

需要注意的是 
点赞接口设计到两个缓存 
第一个即上面说到的 zset 结构  保存的是 userId-> noteId: 关注时间
第二个是 bloom 过滤器 保存的是其实也是 userId 所点赞过的 noteId 的集合 只不过是以布隆的形式保存的
所以在这个接口逻辑中 需要先检测布隆 然后再 reids 的 ZSET 最后数据库 三层检测
对应的 添加新数据的时候 也需要添加布隆 添加 redis 的 ZSET 最后添加到数据库中
```

## 用户关注关系缓存

```
zset 结构
key 结构  following: 用户 ID
value  集合形式 关注用户的 userID 的集合 
score   权重为关注时间的时间戳
```

## 计数模块

```
计数模块统一采用的 Hash 数据结构
笔记维度的 key 为 count:note:noteID
其子维度 key 就是数据库中的字段

同理
用户维度的 key 就是 count:user:userID
```

# 各接口流程总结



# 面试可能会问的

## 为何要引入Lua

```
主要目的：实现 Redis 操作的原子性

遇到的问题：关注接口编写完毕之后发现的问题
关注接口的逻辑：判断是否是自己的用户 Id--> 校验 userIe 是否合理（openFeign 远程调用）---> Lua 检测（是否达到上线-> 是否已经关注-> 添加当前记录）--> 异步落库消费
期中 zset 不会进行永久缓存 是有过期时间的
检测是否关注数量达到了上线(ZSET 的 ZCARD 指令)  这一步骤中：如果 zset 不存在，我们会去查库，查当前用户关注列表
如果没有记录 说明是当前用户是第一次关注人  初始化 zset 然后直接 ZADD 就行
如果有记录，则将记录全量同步到 zset 中即可之后再次执行 Lua 检测步骤即可（成功不用管 会出现已经关注和超限两种异常 抛出对应的异常即可）

在这个过程中 因为关注人数有 100 的限制 如果不是 Lua 进行原子操作 而是分开执行 redis 指令检测是否达到人数上限-> 是否已经关注-> 添加当前记录  并发情况下  用户连续关注两个用户  而用户关注量已经达到了 99  关注 A 的时候检测通过但是还有添加当前记录 也就是当关注 B 的时候 99 还没变为 100  所以就会导致最终结果 AB 都关注成功变为了 101  这是不被允许的 这就需要保证 执行 redis 指令检测是否上线-> 是否已经关注-> 添加当前记录  这三条指令需要原子性 不被其他线程打断 所以引入 Lua
```

## 分布式ID技术选型

```
传统 ID 选取方法：UUID  数据库自增主键 ID  雪花算法  redis 自增键
UUID 无规则  非递增规律  无业务含义 很长  不适合做主键  UUID 基于 MAC 生成容易造成 MAC 泄露容易造成安全问题
自增主键  强依赖 DB  如果后续分库分表 难以保证 ID 唯一
雪花算法  容易被机器时钟干扰
Redis 中自增键  redis i
中间件类似于 zookeeper 分布式协调 ID  引入了新的中间件 增加了系统复杂性
```



## Cassandra选型原因

```
1：
MySQL 存储，可能会因为文本过长导致 InnoDB 行溢出，从而一个文本数据需要多个页来存储和访问，意味读取和操作的时候需要更多的磁盘 IO 操作，影响效率 
文本长度不定的时候，容易导致页的填充效率不高，容易导致内存碎片 ； 
长文本一般只能进行前缀索引，不是很好
长文本中可能容易出现频繁的修改更新，对于 MySQL 而言操作过多开销大
2：
内存性非关系型数据库  例如 Redis
长文本数据量一般会比较大 而且这类数据基本都需要持久化 内存比较昂贵  不适合
3：
分布式文档模型存储数据  例如 MongDB
其实也挺适合的  但是高可用和高性能程度上不如 kv 存储系统
4：
KV 存储系统  美团 阿里 腾讯  小红书 都有自己内部的 kv 系统
适合进行 数据存储量大且相互之间轻关系数据 保存在硬盘上
cassandra
```



## 布隆过滤器的使用和选择原因





## 异步MQ落库 +  BufferTrigger聚合 + Guava令牌限流 使用介绍和原因

这一套在用户点赞笔记，用户收藏笔记中都有使用到

首先来理清楚每一个步骤的作用：

**异步MQ落库是为了防止线程阻塞，采用异步的方式执行落库的操作，是的接口的返回更加快**

**BufferTrigger是为了减少低效率的操作频繁的操作Redis和数据库，减轻数据库压力**

**Guava其实也是限流的作用，也是为了减少数据库的压力**

那么我们再来看用户点赞笔记接口中的整体逻辑，如何搭配使用上面的一套

1. **用户点赞笔记--->基础接口逻辑的信息校验，操作布隆和zset缓存数据--->异步MQ消息**
2. **Consumer接收到消息后消费，消费逻辑包括：判断点赞还是取消点赞，将数据整合到MySQL中，然后再次MQ到计数模块进行异步消费** 
3. **计数模块消费者接收到消息之后，进行消费，对数量进行统计更新**

其实主要作用在2和3的步骤中,在实际逻辑中，BufferTrigger作用在第二个步骤中，Guava在2，3中都可使用

BufferTrigger主要是和计数服务绑定的，在调用计数服务之前的模块，都应该适当的进行聚合操作，因为计数模块不需要在乎新增或者减少的细节，只需要一个聚合后的总体操作，所以其实2中使用BufferTrigger是为3服务

